{"version":3,"file":"photos-src_mixins_FetchFilesMixin_js.js?v=ffb4cce0b182b4d7d2b7","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///photos/src/mixins/FetchFilesMixin.js","webpack:///photos/src/services/PhotoSearch.js"],"sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * @copyright Copyright (c) 2022 Louis Chemineau <louis@chmn.me>\n *\n * @author Louis Chemineau <louis@chmn.me>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\nimport logger from '../services/logger.js';\nimport getPhotos from '../services/PhotoSearch.js';\nimport SemaphoreWithPriority from '../utils/semaphoreWithPriority.js';\nimport AbortControllerMixin from './AbortControllerMixin.js';\nexport default {\n  name: 'FetchFilesMixin',\n  mixins: [AbortControllerMixin],\n  data: function data() {\n    return {\n      errorFetchingFiles: null,\n      loadingFiles: false,\n      doneFetchingFiles: false,\n      semaphore: new SemaphoreWithPriority(30),\n      fetchSemaphore: new SemaphoreWithPriority(1),\n      semaphoreSymbol: null,\n      fetchedFileIds: []\n    };\n  },\n  watch: {\n    $route: function $route() {\n      this.resetFetchFilesState();\n    }\n  },\n  methods: {\n    /**\n     * @param {string} path - Path to pass to getPhotos.\n     * @param {object} options - Options to pass to getPhotos.\n     * @param {string[]} [blacklist=[]] - Array of ids to filter out.\n     * @param {boolean} [force=false] - Force fetching even if doneFetchingFiles is true\n     * @return {Promise<string[]>} - The next batch of data depending on global offset.\n     */\n    fetchFiles: function fetchFiles() {\n      var _arguments = arguments,\n          _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var path, options, blacklist, force, semaphoreSymbol, fetchSemaphoreSymbol, _this$fetchedFileIds, numberOfImagesPerBatch, fetchedFiles, fileIds, _error$response;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                path = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : '';\n                options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};\n                blacklist = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : [];\n                force = _arguments.length > 3 && _arguments[3] !== undefined ? _arguments[3] : false;\n\n                if (!(_this.doneFetchingFiles && !force || _this.loadingFiles)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", []);\n\n              case 6:\n                _context.next = 8;\n                return _this.semaphore.acquire(function () {\n                  return 0;\n                }, 'fetchFiles');\n\n              case 8:\n                semaphoreSymbol = _context.sent;\n                _context.next = 11;\n                return _this.fetchSemaphore.acquire();\n\n              case 11:\n                fetchSemaphoreSymbol = _context.sent;\n                _context.prev = 12;\n                _this.errorFetchingFiles = null;\n                _this.loadingFiles = true;\n                _this.semaphoreSymbol = semaphoreSymbol;\n                numberOfImagesPerBatch = 200; // Load next batch of images\n\n                _context.next = 19;\n                return getPhotos(path, _objectSpread(_objectSpread({\n                  firstResult: _this.fetchedFileIds.length,\n                  nbResults: numberOfImagesPerBatch\n                }, options), {}, {\n                  signal: _this.abortController.signal\n                }));\n\n              case 19:\n                fetchedFiles = _context.sent;\n\n                // If we get less files than requested that means we got to the end\n                if (fetchedFiles.length !== numberOfImagesPerBatch) {\n                  _this.doneFetchingFiles = true;\n                }\n\n                fileIds = fetchedFiles.map(function (file) {\n                  return file.fileid;\n                }).filter(function (fileId) {\n                  return !_this.fetchedFileIds.includes(fileId);\n                }); // Filter to prevent duplicate fileIds.\n\n                (_this$fetchedFileIds = _this.fetchedFileIds).push.apply(_this$fetchedFileIds, _toConsumableArray(fileIds.map(function (fileId) {\n                  return fileId.toString();\n                }).filter(function (fileId) {\n                  return !blacklist.includes(fileId);\n                })));\n\n                _this.$store.dispatch('appendFiles', fetchedFiles);\n\n                logger.debug(\"[FetchFilesMixin] Fetched \".concat(fileIds.length, \" new files: \"), fileIds);\n                return _context.abrupt(\"return\", fileIds);\n\n              case 28:\n                _context.prev = 28;\n                _context.t0 = _context[\"catch\"](12);\n\n                if (!(((_error$response = _context.t0.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 404)) {\n                  _context.next = 34;\n                  break;\n                }\n\n                _this.errorFetchingFiles = 404;\n                _context.next = 39;\n                break;\n\n              case 34:\n                if (!(_context.t0.code === 'ERR_CANCELED')) {\n                  _context.next = 38;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", []);\n\n              case 38:\n                _this.errorFetchingFiles = _context.t0;\n\n              case 39:\n                // cancelled request, moving on...\n                logger.error('Error fetching files', {\n                  error: _context.t0\n                });\n                console.error(_context.t0);\n\n              case 41:\n                _context.prev = 41;\n                _this.loadingFiles = false;\n\n                _this.semaphore.release(semaphoreSymbol);\n\n                _this.fetchSemaphore.release(fetchSemaphoreSymbol);\n\n                return _context.finish(41);\n\n              case 46:\n                return _context.abrupt(\"return\", []);\n\n              case 47:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[12, 28, 41, 46]]);\n      }))();\n    },\n    resetFetchFilesState: function resetFetchFilesState() {\n      this.doneFetchingFiles = false;\n      this.errorFetchingFiles = null;\n      this.loadingFiles = false;\n      this.fetchedFileIds = [];\n    }\n  }\n};","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * @copyright Copyright (c) 2019 John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @author John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\nimport { genFileInfo } from '../utils/fileUtils.js';\nimport { getCurrentUser } from '@nextcloud/auth';\nimport { allMimes } from './AllowedMimes.js';\nimport client from './DavClient.js';\nimport { props } from './DavRequest.js';\nimport moment from '@nextcloud/moment';\n/**\n * List files from a folder and filter out unwanted mimes\n *\n * @param {object} path the lookup path\n * @param {object} [options] used for the cancellable requests\n * @param {number} [options.firstResult=0] Index of the first result that we want (starts at 0)\n * @param {number} [options.nbResults=200] The number of file to fetch\n * @param {string[]} [options.mimesType=allMimes] Mime type of the files\n * @param {boolean} [options.full=false] get full data of the files\n * @param {boolean} [options.onThisDay=false] get only items from this day of year\n * @param {boolean} [options.onlyFavorites=false] get only favorite items\n * @return {Promise<object[]>} the file list\n */\n\nexport default function () {\n  return _ref.apply(this, arguments);\n}\n\nfunction _ref() {\n  _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n    var path,\n        options,\n        prefixPath,\n        orMime,\n        eqFavorites,\n        onThisDay,\n        response,\n        _args = arguments;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            path = _args.length > 0 && _args[0] !== undefined ? _args[0] : '';\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            // default function options\n            options = _objectSpread({\n              firstResult: 0,\n              nbResults: 200,\n              mimesType: allMimes,\n              onThisDay: false,\n              onlyFavorites: false\n            }, options);\n            prefixPath = \"/files/\".concat(getCurrentUser().uid); // generating the search or condition\n            // based on the allowed mimetypes\n\n            orMime = options.mimesType.reduce(function (str, mime) {\n              return \"\".concat(str, \"\\n\\t\\t<d:eq>\\n\\t\\t\\t<d:prop>\\n\\t\\t\\t\\t<d:getcontenttype/>\\n\\t\\t\\t</d:prop>\\n\\t\\t\\t<d:literal>\").concat(mime, \"</d:literal>\\n\\t\\t</d:eq>\\n\\t\");\n            }, '');\n            eqFavorites = options.onlyFavorites ? \"<d:eq>\\n\\t\\t\\t\\t<d:prop>\\n\\t\\t\\t\\t\\t<oc:favorite/>\\n\\t\\t\\t\\t</d:prop>\\n\\t\\t\\t\\t<d:literal>1</d:literal>\\n\\t\\t\\t</d:eq>\" : '';\n            onThisDay = options.onThisDay ? \"<d:or>\".concat(Array(20).fill(1).map(function (_, years) {\n              var start = moment(Date.now()).startOf('day').subtract(3, 'd').subtract(years + 1, 'y');\n              var end = moment(Date.now()).endOf('day').add(3, 'd').subtract(years + 1, 'y');\n              return \"<d:and>\\n\\t\\t\\t\\t<d:gt>\\n\\t\\t\\t\\t\\t<d:prop>\\n\\t\\t\\t\\t\\t\\t<d:getlastmodified />\\n\\t\\t\\t\\t\\t</d:prop>\\n\\t\\t\\t\\t\\t<d:literal>\".concat(start.format(moment.defaultFormatUtc), \"</d:literal>\\n\\t\\t\\t\\t</d:gt>\\n\\t\\t\\t\\t<d:lt>\\n\\t\\t\\t\\t\\t<d:prop>\\n\\t\\t\\t\\t\\t\\t<d:getlastmodified />\\n\\t\\t\\t\\t\\t</d:prop>\\n\\t\\t\\t\\t\\t<d:literal>\").concat(end.format(moment.defaultFormatUtc), \"</d:literal>\\n\\t\\t\\t\\t</d:lt>\\n\\t\\t\\t</d:and>\");\n            }).join('\\n'), \"</d:or>\") : '';\n            options = Object.assign({\n              method: 'SEARCH',\n              headers: {\n                'content-Type': 'text/xml'\n              },\n              data: \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\\t\\t\\t<d:searchrequest xmlns:d=\\\"DAV:\\\"\\n\\t\\t\\t\\txmlns:oc=\\\"http://owncloud.org/ns\\\"\\n\\t\\t\\t\\txmlns:nc=\\\"http://nextcloud.org/ns\\\"\\n\\t\\t\\t\\txmlns:ns=\\\"https://github.com/icewind1991/SearchDAV/ns\\\"\\n\\t\\t\\t\\txmlns:ocs=\\\"http://open-collaboration-services.org/ns\\\">\\n\\t\\t\\t\\t<d:basicsearch>\\n\\t\\t\\t\\t\\t<d:select>\\n\\t\\t\\t\\t\\t\\t<d:prop>\\n\\t\\t\\t\\t\\t\\t\\t\".concat(props, \"\\n\\t\\t\\t\\t\\t\\t</d:prop>\\n\\t\\t\\t\\t\\t</d:select>\\n\\t\\t\\t\\t\\t<d:from>\\n\\t\\t\\t\\t\\t\\t<d:scope>\\n\\t\\t\\t\\t\\t\\t\\t<d:href>\").concat(prefixPath, \"/\").concat(path, \"</d:href>\\n\\t\\t\\t\\t\\t\\t\\t<d:depth>infinity</d:depth>\\n\\t\\t\\t\\t\\t\\t</d:scope>\\n\\t\\t\\t\\t\\t</d:from>\\n\\t\\t\\t\\t\\t<d:where>\\n\\t\\t\\t\\t\\t\\t<d:and>\\n\\t\\t\\t\\t\\t\\t\\t<d:or>\\n\\t\\t\\t\\t\\t\\t\\t\\t\").concat(orMime, \"\\n\\t\\t\\t\\t\\t\\t\\t</d:or>\\n\\t\\t\\t\\t\\t\\t\\t\").concat(eqFavorites, \"\\n\\t\\t\\t\\t\\t\\t\\t\").concat(onThisDay, \"\\n\\t\\t\\t\\t\\t\\t</d:and>\\n\\t\\t\\t\\t\\t</d:where>\\n\\t\\t\\t\\t\\t<d:orderby>\\n\\t\\t\\t\\t\\t\\t<d:order>\\n\\t\\t\\t\\t\\t\\t\\t<d:prop><d:getlastmodified/></d:prop>\\n\\t\\t\\t\\t\\t\\t\\t<d:descending/>\\n\\t\\t\\t\\t\\t\\t</d:order>\\n\\t\\t\\t\\t\\t</d:orderby>\\n\\t\\t\\t\\t\\t<d:limit>\\n\\t\\t\\t\\t\\t\\t<d:nresults>\").concat(options.nbResults, \"</d:nresults>\\n\\t\\t\\t\\t\\t\\t<ns:firstresult>\").concat(options.firstResult, \"</ns:firstresult>\\n\\t\\t\\t\\t\\t</d:limit>\\n\\t\\t\\t\\t</d:basicsearch>\\n\\t\\t\\t</d:searchrequest>\"),\n              deep: true,\n              details: true\n            }, options);\n            _context.next = 10;\n            return client.getDirectoryContents('', options);\n\n          case 10:\n            response = _context.sent;\n            return _context.abrupt(\"return\", response.data.map(function (data) {\n              return genFileInfo(data);\n            }));\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _ref.apply(this, arguments);\n}"],"names":[],"sourceRoot":""}